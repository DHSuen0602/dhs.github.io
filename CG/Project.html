<html>
<head>
  <title>City Runner: Escape the Undead</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { 
      margin: 0; 
      background: #111; 
      color: #fff; 
      font-family: Arial, sans-serif; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      height: 100vh; 
      overflow: hidden;
    }
    #game-container { 
      box-shadow: 0 6px 30px rgba(0,0,0,0.6); 
    }
    canvas { 
      display: block; 
    }
    .instructions { 
      text-align: center; 
      margin-top: 8px; 
      font-size: 13px; 
      color: #ddd; 
    }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <script src="libraries/p5.min.js" type="text/javascript"></script>
  <script src="libraries/p5.sound.min.js" type="text/javascript"></script>

  <script>
  // ======================================
  // City Runner
  // ======================================

  // Game states
  let gameState = "cutscene";

  // Background layers
  let sky, city, building, front;
  let cityX = 0, buildingX = 0, frontX = 0;

  // Assets
  let runSheet, jumpSheet;
  let zombieSheets = [];

  // Player + world
  let player;
  let obstacles = [];
  let coins = [];
  let score = 0;
  let gravity = 0.8;
  let groundY = 310;
  let canvasW = 1000;
  let canvasH = 500;

  function preload() {
    // Background layers
    sky = loadImage("sky.png");
    city = loadImage("city.png");
    building = loadImage("building.png");
    front = loadImage("front.png");

    // Player sheets
    runSheet = loadImage("Running.png");
    jumpSheet = loadImage("Jumping.png");

    // Zombies
    for (let i = 1; i <= 4; i++) zombieSheets.push(loadImage(`zombie${i}.png`));
  }

  function setup() {
    const cnv = createCanvas(canvasW, canvasH);
    cnv.parent('game-container');
    player = new Player();
  }

  function draw() {
    if (gameState === "cutscene") drawCutscene();
    else if (gameState === "start") drawStartScreen();
    else if (gameState === "play") playGame();
    else if (gameState === "gameover") drawGameOver();
  }

  // --------------------------
  // Cutscene
  // --------------------------
  function drawCutscene() {
    background(22, 16, 20);
    fill(180);
    textAlign(CENTER);
    textSize(26);
    text("You wake up in a dark hospital room...", width/2, height/2 - 60);
    textSize(20);
    text("It feels cold. Your head hurts.", width/2, height/2 - 25);

    fill(255, 80, 80);
    textSize(24);
    text("A zombie bursts through the door!", width/2, height/2 + 15);

    fill(220);
    textSize(16);
    text("Press ENTER to jump out the window and escape!", width/2, height/2 + 60);
    textSize(12);
    text("(Or SPACE to skip)", width/2, height/2 + 88);
  }

  // --------------------------
  // Start Screen
  // --------------------------
  function drawStartScreen() {
    background(12);
    fill(255, 120, 120);
    textSize(28);
    textAlign(CENTER);
    text("CITY RUNNER: ESCAPE THE UNDEAD", width / 2, height / 2 - 80);

    fill(255);
    textSize(16);
    text("Use SPACE to Jump. Avoid zombies. Collect coins.", width/2, height/2 - 18);

    fill(180);
    textSize(18);
    text("Press SPACE to Start Running!", width / 2, height / 2 + 24);
  }

  // --------------------------
  // GAMEPLAY (with scrolling background)
  // --------------------------
  function playGame() {
    drawBuildings();

    // street
    fill(35);
    rect(0, groundY + 10, width, height - (groundY + 10));

    // spawn zombie
    if (frameCount % 120 === 0)
      obstacles.push(new ZombieObstacle(random(zombieSheets)));

    // spawn coins
    if (frameCount % 150 === 0)
      coins.push(new Coin());

    // player
    player.update();
    player.display();

    // obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].update();
      obstacles[i].display();

      if (obstacles[i].x < -100) obstacles.splice(i, 1);
      if (player.hits(obstacles[i])) {
        gameState = "gameover";
      }
    }

    // coins
    for (let i = coins.length - 1; i >= 0; i--) {
      coins[i].update();
      coins[i].display();

      if (coins[i].x < -50) coins.splice(i, 1);
      if (player.collects(coins[i])) {
        score += 10;
        coins.splice(i, 1);
      }
    }

    // HUD
    fill(255);
    textSize(18);
    text("Score: " + score, 40, 30);

    if (frameCount % 20 === 0) score++;
  }

  // --------------------------
  // SCROLLING BACKGROUND
  // --------------------------
  function drawBuildings() {
    // SKY
    image(sky, 0, 0, width, height);

    // CITY (slow)
    cityX -= 1;
    if (cityX <= -width) cityX = 0;
    image(city, cityX, 0, width, height);
    image(city, cityX + width, 0, width, height);

    // BUILDING (medium)
    buildingX -= 2;
    if (buildingX <= -width) buildingX = 0;
    image(building, buildingX, 0, width, height);
    image(building, buildingX + width, 0, width, height);

    // FRONT (fast)
    frontX -= 4;
    if (frontX <= -width) frontX = 0;
    image(front, frontX, 0, width, height);
    image(front, frontX + width, 0, width, height);
  }

  // --------------------------
  // GAME OVER
  // --------------------------
  function drawGameOver() {
    background(8, 8, 12);
    fill(255, 70, 70);
    textSize(34);
    textAlign(CENTER);
    text("GAME OVER", width/2, height/2 - 40);

    fill(240);
    textSize(20);
    text("Final Score: " + score, width/2, height/2 + 10);
    textSize(16);
    text("Press R to Restart", width/2, height/2 + 48);
  }

  function resetGame() {
    player = new Player();
    obstacles = [];
    coins = [];
    score = 0;
  }

  // ===========================================================
  // PLAYER CLASS
  // ===========================================================
  class Player {
    constructor() {
      this.x = 100;
      this.y = groundY;
      this.vy = 0;
      this.size = 100;
      this.onGround = true;

      this.runFrames = [];
      this.jumpFrames = [];
      this.animIndex = 0;
      this.animSpeed = 5;

      let runCount = round(runSheet.width / runSheet.height);
      sliceFramesToArray(runSheet, this.runFrames, runCount);

      let jumpCount = round(jumpSheet.width / jumpSheet.height);
      sliceFramesToArray(jumpSheet, this.jumpFrames, jumpCount);
    }

    jump() {
      if (this.onGround) {
        this.vy = -15;
        this.onGround = false;
      }
    }

    update() {
      this.y += this.vy;
      this.vy += gravity;

      if (this.y > groundY) {
        this.y = groundY;
        this.vy = 0;
        this.onGround = true;
      }

      if (this.onGround) {
        if (frameCount % this.animSpeed === 0)
          this.animIndex = (this.animIndex + 1) % this.runFrames.length;
      } else {
        let progress = map(this.vy, -18, 18, 0, 1);
        progress = constrain(progress, 0, 1);
        this.animIndex = floor(progress * (this.jumpFrames.length - 1));
      }
    }

    display() {
      push();
      translate(this.x, this.y - this.size);
      imageMode(CENTER);

      let f = this.onGround
        ? this.runFrames[this.animIndex % this.runFrames.length]
        : this.jumpFrames[this.animIndex];

      image(f, 0, this.size/2, this.size, this.size);
      pop();
    }

    hits(obstacle) {
      let playerWidth = this.size * 0.35;
      let playerHeight = this.size * 0.45;
      let playerLeft = this.x - playerWidth/2;
      let playerRight = this.x + playerWidth/2;
      let playerTop = (this.y - this.size) + (this.size/2 - playerHeight/2);
      let playerBottom = playerTop + playerHeight;

      let zombieWidth = obstacle.size * 0.35;
      let zombieHeight = obstacle.size * 0.45;
      let zombieLeft = obstacle.x - zombieWidth/2;
      let zombieRight = obstacle.x + zombieWidth/2;
      let zombieTop = (obstacle.y - obstacle.size/2) + (obstacle.size/2 - zombieHeight/2);
      let zombieBottom = zombieTop + zombieHeight;

      return (playerLeft < zombieRight &&
              playerRight > zombieLeft &&
              playerTop < zombieBottom &&
              playerBottom > zombieTop);
    }

    collects(coin) {
      return collideRectRect(
        this.x - this.size/2, this.y - this.size, this.size, this.size,
        coin.x - coin.size/2, coin.y - coin.size/2, coin.size, coin.size
      );
    }
  }

  // ===========================================================
  // ZOMBIE
  // ===========================================================
  class ZombieObstacle {
    constructor(sheetImg) {
      this.sheet = sheetImg;
      this.size = 90;
      this.x = width + random(20, 160);
      this.y = groundY - this.size / 2;
      this.speed = 6 + random(0, 1.5);

      let est = round(this.sheet.width / this.sheet.height);
      this.totalFrames = est;
      this.frameW = this.sheet.width / est;
      this.frameH = this.sheet.height;
      this.frameIndex = 0;
    }

    update() {
      this.x -= this.speed;
      if (frameCount % 12 === 0) this.frameIndex = (this.frameIndex + 1) % this.totalFrames;
    }

    display() {
      image(
        this.sheet,
        this.x, this.y - this.size/2,
        this.size, this.size,
        this.frameIndex * this.frameW, 0,
        this.frameW, this.frameH
      );
    }
  }

  // ===========================================================
  // COIN
  // ===========================================================
  class Coin {
    constructor() {
      this.size = 20;
      this.x = width + random(10, 200);
      this.y = random(groundY - 120, groundY - 40);
      this.speed = 6;
      this.angle = random(TWO_PI);
    }

    update() {
      this.x -= this.speed;
      this.angle += 0.12;
    }

    display() {
      push();
      translate(this.x, this.y);
      rotate(this.angle);
      fill(255, 200, 0);
      ellipse(0, 0, this.size);
      fill(255, 240, 150);
      ellipse(0, 0, this.size * 0.45);
      pop();
    }
  }

  // ===========================================================
  // UTILS
  // ===========================================================
  function sliceFramesToArray(sheet, arr, frameNum) {
    let w = sheet.width / frameNum;
    let h = sheet.height;
    for (let i = 0; i < frameNum; i++)
      arr.push(sheet.get(i * w, 0, w, h));
  }

  // ===========================================================
  // INPUT
  // ===========================================================
  function keyPressed() {
    if (gameState === "cutscene") {
      if (keyCode === ENTER || key === " ") gameState = "start";
    } 
    else if (gameState === "start") {
      if (key === " ") {
        resetGame();
        gameState = "play";
      }
    } 
    else if (gameState === "play") {
      if (key === " ") player.jump();
    } 
    else if (gameState === "gameover") {
      if (key === "r" || key === "R") {
        resetGame();
        gameState = "play";
      }
    }
  }
  </script>
</body>

</html>

